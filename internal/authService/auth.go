package auth

import (
	"context"
	"crypto/rand"
	"errors"
	"fmt"
	"os"
	"strings"
	"time"

	"connectrpc.com/connect"
	authv1 "github.com/alexey-petrov/go-webauthn/gen/auth/v1" // generated by protoc-gen-go
	dbv1 "github.com/alexey-petrov/go-webauthn/gen/db/v1"
	"github.com/alexey-petrov/go-webauthn/gen/db/v1/dbv1connect"
	"github.com/alexey-petrov/go-webauthn/internal/jwtService"
	"github.com/alexey-petrov/go-webauthn/internal/storage"
	namesgenerator "github.com/docker/docker/pkg/namesgenerator"
)

type User struct {
	Email     string `json:"email"`
	Password  string `json:"password"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
}

type AuthServiceServer struct {
	cacheClient dbv1connect.ErdtreeStoreClient
	userService *storage.UserService
	jwtService  *jwtService.JwtServiceStore
}

func NewExternalClient(baseURL string, userService *storage.UserService, jwtService *jwtService.JwtServiceStore, erdtreeClient dbv1connect.ErdtreeStoreClient) *AuthServiceServer {
	return &AuthServiceServer{
		cacheClient: erdtreeClient,
		userService: userService,
		jwtService:  jwtService,
	}
}

func (s *AuthServiceServer) RefreshAccessToken(
	ctx context.Context,
	req *connect.Request[authv1.RefreshAccessTokenRequest],
) (*connect.Response[authv1.RefreshAccessTokenResponse], error) {
	var err error

	token, err := s.jwtService.RefreshAccessToken(req.Msg.UserId, req.Msg.AccessToken)

	if err != nil {
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	res := connect.NewResponse(&authv1.RefreshAccessTokenResponse{
		AccessToken: token,
	})

	erdtreeReq := connect.NewRequest(&dbv1.SetRequest{
		Key:   req.Msg.UserId + "-refreshToken",
		Value: []byte(time.Now().UTC().String()),
	})
	_, err = s.cacheClient.Set(ctx, erdtreeReq)

	if err != nil {
		fmt.Println("Error setting refresh token record in Erdtree:", err)
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	res.Header().Set("Set-Cookie", jwtService.GetConnectRpcAccessTokenCookie(token))

	return res, nil
}

func (s *AuthServiceServer) Register(
	ctx context.Context,
	req *connect.Request[authv1.RegisterRequest],
) (*connect.Response[authv1.RegisterResponse], error) {
	var err error

	id, err := s.userService.CreateAdmin(req.Msg.Email, req.Msg.Password, req.Msg.FirstName, req.Msg.LastName)

	if err != nil {
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	token, err := s.jwtService.GenerateJWTPair(id)

	if err != nil {
		fmt.Println("Error generating JWT:", err)
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	erdtreeReq := connect.NewRequest(&dbv1.SetRequest{
		Key:   id + "-register",
		Value: []byte(time.Now().UTC().String()),
	})
	_, err = s.cacheClient.Set(ctx, erdtreeReq)

	if err != nil {
		fmt.Println("Error setting register record in Erdtree:", err)
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	res := connect.NewResponse(&authv1.RegisterResponse{
		AccessToken: token,
	})

	res.Header().Set("Set-Cookie", jwtService.GetConnectRpcAccessTokenCookie(token))

	return res, nil
}

func (s *AuthServiceServer) Login(
	ctx context.Context,
	req *connect.Request[authv1.LoginRequest],
) (*connect.Response[authv1.LoginResponse], error) {
	userData, err := s.userService.LoginAsAdmin(req.Msg.Email, req.Msg.Password)

	if err != nil {
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("unauth: failed to login. invalid credentials"))
	}

	s.jwtService.RevokeJWTByUserId(userData.UserId)

	token, err := s.jwtService.GenerateJWTPair(userData.UserId)

	if err != nil {
		fmt.Println("Error generating JWT:", err)
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	erdtreeReq := connect.NewRequest(&dbv1.SetRequest{
		Key:   userData.UserId + "-login",
		Value: []byte(time.Now().UTC().String()),
	})
	_, err = s.cacheClient.Set(ctx, erdtreeReq)

	if err != nil {
		fmt.Println("Error setting login record in Erdtree:", err)
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	res := connect.NewResponse(&authv1.LoginResponse{
		AccessToken: token,
	})
	res.Header().Set("Set-Cookie", jwtService.GetConnectRpcAccessTokenCookie(token))
	return res, nil
}

func (s *AuthServiceServer) Logout(
	ctx context.Context,
	req *connect.Request[authv1.LogoutRequest],
) (*connect.Response[authv1.LogoutResponse], error) {

	err := s.jwtService.RevokeJwtByJwtToken(req.Msg.AccessToken)

	if err != nil {
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	res := connect.NewResponse(&authv1.LogoutResponse{
		Ok: true,
	})

	res.Header().Set("Set-Cookie", jwtService.GetConnectRpcAccessTokenCookie(""))

	return res, nil
}

func generateChallenge() ([]byte, error) {
	challenge := make([]byte, 32)
	_, err := rand.Read(challenge)
	return challenge, err
}

func (s *AuthServiceServer) BeginRegistration(
	ctx context.Context,
	req *connect.Request[authv1.BeginRegistrationRequest],
) (*connect.Response[authv1.BeginRegistrationResponse], error) {
	challenge, err := generateChallenge()
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	RpID := "localhost"

	if os.Getenv("PUBLIC_URL") != "" {
		RpID = os.Getenv("PUBLIC_DOMAIN")
	}

	// Respond with challenge and relying party (RP) ID
	resp := &authv1.BeginRegistrationResponse{
		Challenge: challenge,
		RpId:      RpID, // Replace with your RP ID (your domain)
	}
	return connect.NewResponse(resp), nil
}

func (s *AuthServiceServer) FinishRegistration(
	ctx context.Context,
	req *connect.Request[authv1.FinishRegistrationRequest],
) (*connect.Response[authv1.FinishRegistrationResponse], error) {

	credentialID := req.Msg.CredentialId
	attestationObject := req.Msg.AttestationObject
	// clientDataJSON := req.Msg.ClientDataJson

	// Here, you would validate the attestationObject and clientDataJSON
	// Extract the public key from the attestationObject (omitted for simplicity)
	// Step 1: Decode and parse the attestationObject
	authenticatorData, publicKey, err := parseAttestationObject(attestationObject)
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid attestation object"))
	}
	// // Step 2: Validate the attestation (signature, certificate chain, etc.)
	// if err := validateAttestation(attestationObject, clientDataJSON, authenticatorData); err != nil {
	// 	return nil, connect.NewError(connect.CodeUnauthenticated, err)
	// }

	nickName := strings.SplitN(namesgenerator.GetRandomName(0), "_", 2)
	firstName := nickName[0]
	lastName := nickName[1]
	// Step 3: Store the user's public key and credentials in the database
	user := storage.User{
		CredentialID:        []byte(credentialID),
		PublicKey:           publicKey,
		SignCount:           extractSignCount(authenticatorData), // Initial sign count
		AuthenticatorAAGUID: extractAAGUID(authenticatorData),    // AAGUID for the authenticator
		FirstName:           firstName,
		LastName:            lastName,
	}

	id, err := s.userService.CreateWebAuthnAdmin(&user)

	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	token, err := s.jwtService.GenerateJWTPair(id)

	if err != nil {
		fmt.Println("Error generating JWT:", err)
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	erdtreeReq := connect.NewRequest(&dbv1.SetRequest{
		Key:   id + "-register",
		Value: []byte(time.Now().UTC().String()),
	})
	_, err = s.cacheClient.Set(ctx, erdtreeReq)

	if err != nil {
		fmt.Println("Error setting webauthn register record in Erdtree:", err)
		// return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	res := connect.NewResponse(&authv1.FinishRegistrationResponse{AccessToken: token})

	res.Header().Set("Set-Cookie", jwtService.GetConnectRpcAccessTokenCookie(token))

	return res, nil
}

func (s *AuthServiceServer) BeginLogin(
	ctx context.Context,
	req *connect.Request[authv1.BeginLoginRequest],
) (*connect.Response[authv1.BeginLoginResponse], error) {
	challenge, err := generateChallenge()
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	RpID := "localhost"

	if os.Getenv("PUBLIC_URL") != "" {
		RpID = os.Getenv("PUBLIC_DOMAIN")
	}
	// Respond with challenge and relying party (RP) ID
	resp := &authv1.BeginLoginResponse{
		Challenge: challenge,
		RpId:      RpID, // Replace with your RP ID (your domain)
	}
	return connect.NewResponse(resp), nil
}

func (s *AuthServiceServer) FinishLogin(
	ctx context.Context,
	req *connect.Request[authv1.FinishLoginRequest],
) (*connect.Response[authv1.FinishLoginResponse], error) {
	// Parse the credential response from the client
	credentialID := req.Msg.CredentialId
	authenticatorData := req.Msg.AuthenticatorData
	clientDataJSON := req.Msg.ClientDataJson
	signature := req.Msg.Signature

	// Retrieve the user from the database using the Credential ID
	var user storage.User
	if err := s.userService.GetConnection().Where("credential_id = ?", credentialID).First(&user).Error; err != nil {
		return nil, connect.NewError(connect.CodeNotFound, errors.New("user not found"))
	}
	// Verify the signature using the stored public key
	isValid, err := verifySignature(user.PublicKey, authenticatorData, clientDataJSON, signature)
	if !isValid || err != nil {
		return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("invalid signature"))
	}
	// Ensure the sign count has increased (replay attack protection)
	// Does not work for passkeys/fingerprint
	// newSignCount := extractSignCount(authenticatorData)

	// if newSignCount <= user.SignCount {
	// 	return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("replay attack detected"))
	// }

	_, err = s.userService.LoginAsWebAuthAdmin(user.UserId)

	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	s.jwtService.RevokeJWTByUserId(user.UserId)

	token, err := s.jwtService.GenerateJWTPair(user.UserId)

	if err != nil {
		fmt.Println("Error generating JWT:", err)
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	erdtreeReq := connect.NewRequest(&dbv1.SetRequest{
		Key:   user.UserId + "-login",
		Value: []byte(time.Now().UTC().String()),
	})
	_, err = s.cacheClient.Set(ctx, erdtreeReq)

	if err != nil {
		fmt.Println("Error setting webauthn login record in Erdtree:", err)

		// return nil, connect.NewError(connect.CodeUnauthenticated, errors.New(err.Error()))
	}

	res := connect.NewResponse(&authv1.FinishLoginResponse{AccessToken: token})

	res.Header().Set("Set-Cookie", jwtService.GetConnectRpcAccessTokenCookie(token))

	return res, nil
}
